name: Multi-platform build

on:
  push:
    branches: [ "main", "development" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:
    name: build (${{ matrix.id }})
    runs-on: ${{ matrix.runs_on }}

    strategy:
      fail-fast: false
      matrix:
        include:
          - id: ubuntu-gcc
            runs_on: ubuntu-latest
            build_type: Release
            c_compiler: gcc
            cpp_compiler: g++
            binary_path: bin/Release/chisel

          - id: ubuntu-clang
            runs_on: ubuntu-latest
            build_type: Release
            c_compiler: clang
            cpp_compiler: clang++
            binary_path: bin/Release/chisel

          - id: ubuntu-arm
            runs_on: ubuntu-24.04-arm
            build_type: Release
            c_compiler: gcc
            cpp_compiler: g++
            binary_path: bin/Release/chisel

          - id: macos-intel
            runs_on: macos-15-intel
            build_type: Release
            c_compiler: gcc-12
            cpp_compiler: g++-12
            binary_path: bin/Release/chisel

          - id: macos-arm
            runs_on: macos-26
            build_type: Release
            c_compiler: clang
            cpp_compiler: clang++
            binary_path: bin/Release/chisel

          - id: windows-x86
            runs_on: windows-latest
            build_type: Release
            c_compiler: cl
            cpp_compiler: cl
            binary_path: bin/Release/chisel.exe

          - id: windows-arm
            runs_on: windows-11-arm
            build_type: Release
            c_compiler: cl
            cpp_compiler: cl
            binary_path: bin/Release/chisel.exe

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0
          lfs: true

      - name: Setup Git LFS
        run: |
          git lfs install
          git lfs pull

      - name: Install build dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake ninja-build pkg-config \
            autoconf automake libtool m4 nasm yasm curl unzip tar gzip python3-pip

      - name: Install build dependencies (macOS)
        if: runner.os == 'macOS'
        run: |
          brew update
          brew install autoconf automake libtool nasm yasm curl pipx
          if [[ "$(uname -m)" == "x86_64" ]]; then
            brew install gcc@12
          fi

      - name: Install build dependencies (Windows)
        if: runner.os == 'Windows'
        run: |
          echo "No Windows-specific build dependencies to install via script."
        shell: bash

      - name: Set build output directory
        id: strings
        shell: bash
        run: echo "build-output-dir=${{ github.workspace }}/build" >> "$GITHUB_OUTPUT"

      - name: Configure CMake
        run: >
          cmake -B ${{ steps.strings.outputs.build-output-dir }}
          -DCMAKE_BUILD_TYPE=${{ matrix.build_type }}
          -DCMAKE_CXX_COMPILER=${{ matrix.cpp_compiler }}
          -DCMAKE_C_COMPILER=${{ matrix.c_compiler }}
          -S ${{ github.workspace }}

      - name: Build
        run: cmake --build ${{ steps.strings.outputs.build-output-dir }} --config ${{ matrix.build_type }}

      - name: Upload binary artifact
        uses: actions/upload-artifact@v4
        with:
          name: chisel-${{ matrix.id }}
          path: ${{ github.workspace }}/${{ matrix.binary_path }}
          retention-days: 7

  test:
    name: test (${{ matrix.id }})
    needs: build
    runs-on: ${{ matrix.runs_on }}

    strategy:
      fail-fast: false
      matrix:
        include:
          - id: ubuntu-gcc
            runs_on: ubuntu-latest
          - id: ubuntu-clang
            runs_on: ubuntu-latest
          - id: ubuntu-arm
            runs_on: ubuntu-24.04-arm
          - id: macos-intel
            runs_on: macos-15-intel
          - id: macos-arm
            runs_on: macos-26
          - id: windows-x86
            runs_on: windows-latest
          - id: windows-arm
            runs_on: windows-11-arm

    env:
      TEST_ARCHIVE_NAME: chisel_samples.zip
      TEST_DIR: test-data
      BIN_DIR: bin

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download binary artifact
        uses: actions/download-artifact@v4
        with:
          name: chisel-${{ matrix.id }}
          path: ${{ env.BIN_DIR }}

      - name: Make binary executable
        if: runner.os != 'Windows'
        run: chmod +x ${{ env.BIN_DIR }}/chisel
        shell: bash

      - name: Install test dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-pip unzip
          pip3 install --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib

      - name: Install test dependencies (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install python3 unzip
          python3 -m venv ${{ github.workspace }}/venv-gdrive
          ${{ github.workspace }}/venv-gdrive/bin/pip3 install --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib

      - name: Install test dependencies (Windows)
        if: runner.os == 'Windows'
        run: |
          python -m pip install --upgrade pip
          python -m pip install --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib
        shell: bash

      - name: Cache test data archive
        id: cache-test-archive
        uses: actions/cache@v4
        with:
          path: ${{ env.TEST_ARCHIVE_NAME }}
          key: ${{ runner.os }}-testarchive-v1-${{ secrets.GDRIVE_FILE_ID }}

      - name: Authenticate and Download Test Data from Google Drive
        if: steps.cache-test-archive.outputs.cache-hit != 'true'
        env:
          GDRIVE_CREDENTIALS_JSON: ${{ secrets.GDRIVE_CREDENTIALS_JSON }}
          GDRIVE_FILE_ID: ${{ secrets.GDRIVE_FILE_ID }}
        run: |
          PY_EXE="python3"
          if [[ "$RUNNER_OS" == "Windows" ]]; then
            PY_EXE="python"
          elif [[ "$RUNNER_OS" == "macOS" ]]; then
            # Point to the python inside the venv
            PY_EXE="${{ github.workspace }}/venv-gdrive/bin/python3"
          fi

          "$PY_EXE" -c "
          import os
          import io
          import json
          import sys
          from google.oauth2 import service_account
          from googleapiclient.discovery import build
          from googleapiclient.http import MediaIoBaseDownload
          
          creds_json_string = os.environ.get('GDRIVE_CREDENTIALS_JSON')
          if not creds_json_string:
            print('::error::Secret GDRIVE_CREDENTIALS_JSON is not set.', file=sys.stderr)
            sys.exit(1)
          
          try:
            creds_info = json.loads(creds_json_string)
            creds = service_account.Credentials.from_service_account_info(creds_info)
          except json.JSONDecodeError:
            print('::error::Could not decode credentials JSON. Check the secret.', file=sys.stderr)
            sys.exit(1)
          except Exception as e:
            print(f'::error::Failed to load service account credentials: {e}', file=sys.stderr)
            sys.exit(1)
          
          file_id = os.environ.get('GDRIVE_FILE_ID')
          output_filename = os.environ.get('TEST_ARCHIVE_NAME')
          
          if not file_id:
            print('::error::Secret GDRIVE_FILE_ID is not set.', file=sys.stderr)
            sys.exit(1)
          if not output_filename:
            print('::error::Environment variable TEST_ARCHIVE_NAME is not set.', file=sys.stderr)
            sys.exit(1)
          
            print(f'Authenticating and creating Google Drive service...')
          try:
            service = build('drive', 'v3', credentials=creds)
          except Exception as e:
            print(f'::error::Failed to build Drive service: {e}', file=sys.stderr)
            sys.exit(1)
          
          print(f'Requesting file ID: {file_id}...')
          try:
            request = service.files().get_media(fileId=file_id)
          except Exception as e:
            print(f'::error::Failed to create download request for file ID {file_id}: {e}', file=sys.stderr)
            sys.exit(1)
          
          try:
            print(f'Opening output file: {output_filename}...')
            fh = io.FileIO(output_filename, 'wb')
          except Exception as e:
            print(f'::error::Failed to open output file {output_filename} for writing: {e}', file=sys.stderr)
            sys.exit(1)
          
          downloader = MediaIoBaseDownload(fh, request)
          done = False
          print(f'Starting download -> {output_filename}...')
          try:
            while done is False:
              status, done = downloader.next_chunk()
              if status:
                print(f'Download {int(status.progress() * 100)}%.')
          except Exception as e:
            print(f'::error::Download failed: {e}', file=sys.stderr)
              # Ensure file handle is closed before attempting removal
            if not fh.closed:
              fh.close()
              # Attempt to remove partially downloaded file
              try:
                if os.path.exists(output_filename):
                  os.remove(output_filename)
                  print(f'Removed partially downloaded file: {output_filename}')
              except OSError as oe:
                print(f'Warning: Could not remove partial file {output_filename}: {oe}', file=sys.stderr)
              sys.exit(1)
          finally:
              # Ensure file handle is closed even if download finished successfully
            if not fh.closed:
              fh.close()
          
          print(f'Download complete: {output_filename}.')
            "

        shell: bash

      - name: Extract Test Data
        run: |
          echo "Extracting test data..."
          mkdir ${{ env.TEST_DIR }}
          unzip -q ${{ env.TEST_ARCHIVE_NAME }} -d ${{ env.TEST_DIR }}
        shell: bash

      - name: Run Chisel Tests
        run: |
          if [[ "$RUNNER_OS" == "Windows" ]]; then
            CHISEL_EXE="./${{ env.BIN_DIR }}/chisel.exe"
          else
            CHISEL_EXE="./${{ env.BIN_DIR }}/chisel"
          fi
          echo "Running chisel from: $CHISEL_EXE"
          echo "Processing files in: ${{ env.TEST_DIR }}"
          
          "$CHISEL_EXE" "${{ env.TEST_DIR }}" --recursive --threads 4 --regenerate-magic
        shell: bash

      - name: Check for errors in Chisel Log
        if: always()
        run: |
          LOG_FILE="build/chisel.log"
          if [ ! -f "$LOG_FILE" ]; then
            if [ -f "${{ github.workspace }}/chisel.log" ]; then
              LOG_FILE="${{ github.workspace }}/chisel.log"
            elif [ -f "chisel.log" ]; then
              LOG_FILE="chisel.log"
            else
              echo "Log file not found at build/chisel.log, ${{ github.workspace }}/chisel.log, or current directory."
              exit 0
            fi
          fi
          echo "Checking log file at: $LOG_FILE"
          if grep -q '\[ERROR\]' "$LOG_FILE"; then
            echo "::error::Errors detected in chisel.log!"
            grep '\[ERROR\]' "$LOG_FILE"
            exit 1
          else
            echo "No [ERROR] lines found in chisel.log."
            exit 0
          fi
        shell: bash

      - name: Upload Chisel Log File
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: chisel-log-${{ matrix.id }}
          path: |
            build/chisel.log
            ${{ github.workspace }}/chisel.log
            chisel.log
            if-no-files-found: warn
            retention-days: 7
